import glob
import os
import numpy as np
import nltk
import json
import pickle
from queue import LifoQueue 
from nltk.stem import PorterStemmer
from tkinter import *
porter = PorterStemmer()
dic={}
i_index={}
p_index={}
fObj = open('Stopword-List.txt',mode='r',encoding='utf-8')
stwl = fObj.read()
stwl = stwl.split()

###################################################################################################################################################################################################################################################################################################################################################################################################################
def dictionary_creation(): 
    files = glob.glob('Stories/*') 
    for x in files:
        obj = open(x,mode='r',encoding='utf-8')
        fullfile=obj.read().replace("“"," ").replace(":"," ").replace("”"," ").replace("!"," ").replace("'ve"," have").replace("'m"," am").replace("'re"," are").replace("'d"," would").replace("'ll"," will").replace("'s"," is").replace("'\'"," ").replace("_"," ").replace("."," ").replace("n't"," not").replace("'","").replace("]"," ").replace("["," ").replace(","," ").replace("?"," ").replace("\n"," ").replace("-"," ").split() 
        p=os.path.basename(x)
        p=p.split('.')[0]
        y = []
        for word in fullfile:
            if word not in stwl:
                y.append(porter.stem(word.lower()))
        dic[int(p)]=y
###################################################################################################################################################################################################################################################################################################################################################################################################################
      
        
        
###################################################################################################################################################################################################################################################################################################################################################################################################################       
def read_i_index():
    global i_index
    global p_index
    try:
        i_file = open("Inverted_index.txt",mode='rb')
        p_file = open("p_index.txt",mode='rb')
        i_index = pickle.load(i_file.read())
        p_index = pickle.load(p_file.read())
        if len(i_index) == 0 or len(p_index) == 0:
            check()
    except:
        check()
###################################################################################################################################################################################################################################################################################################################################################################################################################
        
        
###################################################################################################################################################################################################################################################################################################################################################################################################################        
def i_index_creation():
    global i_index
    for key in dic.keys():
        for word in dic[key]:
            if word in stwl:
                continue
            if word not in i_index:
                i_index[word]=[]
                i_index[word].append(key)
            else:
                if key not in i_index[word]:
                    i_index[word].append(key)
    #return i_index           
###################################################################################################################################################################################################################################################################################################################################################################################################################
   
    
    
###################################################################################################################################################################################################################################################################################################################################################################################################################    
def p_index_creation():
    for key in dic.keys():
        count=0
        for word in dic[key]:
            count+=1
            if word in stwl:  # entertaining the presence of stop words in the file (increment index without doing anything)
                continue
            if word not in p_index:
                p_index[word]={}
                p_index[word][key]=[]
                if count not in p_index[word][key]:
                    p_index[word][key].append(count)
            else:
                if key not in p_index[word]:
                    p_index[word][key]=[]
                if count not in p_index[word][key]:
                    p_index[word][key].append(count) 
###################################################################################################################################################################################################################################################################################################################################################################################################################
               
                
 
###################################################################################################################################################################################################################################################################################################################################################################################################################                  
def check():
    dictionary_creation()
    if len(i_index) == 0:
        i_index_creation()
    if len(p_index) == 0:
        p_index_creation()
    write_to_file()
###################################################################################################################################################################################################################################################################################################################################################################################################################



###################################################################################################################################################################################################################################################################################################################################################################################################################
def write_to_file():
    i_file = open("Inverted_index.txt",mode='wb')
    p_file = open("p_index.txt",mode='wb')
    pickle.dump(i_index,i_file)
    pickle.dump(p_index,p_file)
###################################################################################################################################################################################################################################################################################################################################################################################################################
   


###################################################################################################################################################################################################################################################################################################################################################################################################################
def type_query(ss):
    query = ss
    q=query.replace(".","").replace("]"," ").replace("["," ").replace(","," ").replace("?","").replace("/"," / ").split()

    #stemming the query
    Q=[porter.stem(x.lower()) for x in q]

    ss = str(Q)

    swquery = [x for x in Q if x not in stwl]
       
    p_val=0
    #identifying the proximity query
    if '/' in Q:
        p_val = int(swquery[swquery.index('/')+1])
        w1=swquery[0]
        w2=swquery[1]
        if p_val != 0:
            ss += ProximityQueryProcessing(w1,w2,p_val + 1)
        else:
            ss += "invalid proximity query"    
    else :
        ss += complex_query(query)
    return ss
###################################################################################################################################################################################################################################################################################################################################################################################################################


###################################################################################################################################################################################################################################################################################################################################################################################################################
def complex_query(query):
    query = query.split()
    query = [porter.stem(x.lower()) for x in query]
    if len(query) == 1:
        if i_index.get(query[0],0) != 0:
            return str(i_index[query[0]])
        else:
            ans ="Not found "
            return ans
    else:          
        prec = {}  
        prec['not']=3
        prec['or']=2
        prec['and']=1
        pfquery=[]
        myStack=[]
        result=[]
        for q in query:
            if q not in prec:
                pfquery.append(q)
            else:
                while (len(myStack)!=0) and (prec[myStack[-1]]>=prec[q]):
                    pfquery.append(myStack.pop())
                myStack.append(q)                                           
        while len(myStack) !=0:
            pfquery.append(myStack.pop()) 
        r = str(pfquery)                                
        for x in pfquery:
            if x not in prec:
                if i_index.get(x,0) != 0:
                    result.append(set(i_index[x]))
                else:
                    result.append(set()) 
            if x == 'not' :
                y = result.pop()
                result.append(set(dic.keys())-y)     
            if x == 'and' :
                y = result.pop()
                z = result.pop()
                result.append(z.intersection(y))    
            if x == 'or' :
                y = result.pop()
                z = result.pop()
                result.append(z.union(y))   
        r += str(result)
        return r
###################################################################################################################################################################################################################################################################################################################################################################################################################


###################################################################################################################################################################################################################################################################################################################################################################################################################
def checkPositions(word1, word2, ProximityValue,commonDoc): 
    result = []
    for pos1 in word1:
        for pos2 in word2:
            if (abs(pos1-pos2)+1) == ProximityValue:
                print("DOC--> ",commonDoc,"-->pos1(",pos1,") - pos2(",pos2,")",abs(pos1-pos2)-1)
                result.append(commonDoc)
            else:
                  pass
    return result
###################################################################################################################################################################################################################################################################################################################################################################################################################


###################################################################################################################################################################################################################################################################################################################################################################################################################
def ProximityQueryProcessing(w1, w2, ProximityValue):
    global p_index
    word1={}
    word2={}
    for w in p_index.keys():
        if w == w1:
            for docid in p_index[w]:
                word1[docid]=p_index[w][docid]
        elif w == w2:
            for docid in p_index[w]:
                word2[docid]=p_index[w][docid]
                
    s1=set(word1.keys())
    s2=set(word2.keys())
    commonDoc=None
    commonDoc=s1.intersection(s2)
    
    rr= "Set1 : " + str(s1) + "\n\nSet2 : " + str(s2) + "\n\nCommon: " + str(commonDoc) + "\n"
    result=[]
    if commonDoc is not None:
        for Doc in commonDoc:
                x=checkPositions(word1[Doc],word2[Doc], ProximityValue,Doc)
                if len(x)>0:
                    result.append(Doc)
    else:
        rr += "\nresult not found"
        
    rr += "\nTotal Docs : " + str(len(result)) + "\nDocs -->" + str(result)
    return rr    
###################################################################################################################################################################################################################################################################################################################################################################################################################
                                         
###################################################################################################################################################################################################################################################################################################################################################################################################################
def main(ss):
    
    read_i_index()
    #print(i_index)
    while 1:       
        st = type_query(ss)
        return st
###################################################################################################################################################################################################################################################################################################################################################################################################################
root = Tk()
root.resizable(0,0)
fram = Frame(root)
Label(fram,text='Search:').pack(side=LEFT)
string = Entry(fram)
string.pack(side=LEFT, fill=BOTH, expand=1)
string.focus_set()
butt = Button(fram, text='GO!')
butt.pack(side=RIGHT)
fram.pack(side=TOP)
ss = string.get()
st = main(ss)
butt['command'] = main(ss)
text = Text(root)
text.insert('1.0',ss)
text.pack(side=BOTTOM)


root.mainloop()