import glob
import os
import numpy as np
import nltk
import json
import pickle
from queue import LifoQueue 
from nltk.stem import PorterStemmer
from tkinter import *

porter = PorterStemmer()
dic={}
i_index={}
p_index={}
fObj = open('Stopword-List.txt',mode='r',encoding='utf-8')
stwl = fObj.read()
stwl = stwl.split()
st = 's'
###################################################################################################################################################################################################################################################################################################################################################################################################################
def dictionary_creation(): 
    files = glob.glob('Stories/*') 
    for x in files:
        obj = open(x,mode='r',encoding='utf-8')
        fullfile=obj.read().replace("!"," ").replace("'ve"," have").replace("'m"," am").replace("'re"," are").replace("'d"," would").replace("'ll"," will").replace("'s"," is").replace("'\'"," ").replace("_"," ").replace("."," ").replace("n't"," not").replace("'","").replace("]"," ").replace("["," ").replace(","," ").replace("?"," ").replace("\n"," ").replace("-"," ").split() 
        p=os.path.basename(x)
        p=p.split('.')[0]
        y = []
        for word in fullfile:
            if word not in stwl:
                y.append(porter.stem(word))
        dic[int(p)]=y
###################################################################################################################################################################################################################################################################################################################################################################################################################
      
        
        
###################################################################################################################################################################################################################################################################################################################################################################################################################       
def read_i_index():
    global i_index
    global p_index
    try:
        i_file = open("Inverted_index.txt",mode='rb')
        p_file = open("p_index.txt",mode='rb')
        i_index = pickle.load(i_file.read())
        p_index = pickle.load(p_file.read())
        if len(i_index) == 0 or len(p_index) == 0:
            check()
    except:
        check()
###################################################################################################################################################################################################################################################################################################################################################################################################################
        
        
###################################################################################################################################################################################################################################################################################################################################################################################################################        
def i_index_creation():
    global i_index
    for key in dic.keys():
        for word in dic[key]:
            if word in stwl:
                continue
            if word not in i_index:
                i_index[word]=[]
                i_index[word].append(key)
            else:
                if key not in i_index[word]:
                    i_index[word].append(key)
    #return i_index           
###################################################################################################################################################################################################################################################################################################################################################################################################################
   
    
    
###################################################################################################################################################################################################################################################################################################################################################################################################################    
def p_index_creation():
    for key in dic.keys():
        count=0
        for word in dic[key]:
            count+=1
            if word in stwl:  # entertaining the presence of stop words in the file (increment index without doing anything)
                continue
            if word not in p_index:
                p_index[word]={}
                p_index[word][key]=[]
                if count not in p_index[word][key]:
                    p_index[word][key].append(count)
            else:
                if key not in p_index[word]:
                    p_index[word][key]=[]
                if count not in p_index[word][key]:
                    p_index[word][key].append(count) 
###################################################################################################################################################################################################################################################################################################################################################################################################################
               
                
 
###################################################################################################################################################################################################################################################################################################################################################################################################################                  
def check():
    dictionary_creation()
    if len(i_index) == 0:
        i_index_creation()
    if len(p_index) == 0:
        p_index_creation()
    write_to_file()
###################################################################################################################################################################################################################################################################################################################################################################################################################



###################################################################################################################################################################################################################################################################################################################################################################################################################
def write_to_file():
    i_file = open("Inverted_index.txt",mode='wb')
    p_file = open("p_index.txt",mode='wb')
    pickle.dump(i_index,i_file)
    pickle.dump(p_index,p_file)
###################################################################################################################################################################################################################################################################################################################################################################################################################
   


###################################################################################################################################################################################################################################################################################################################################################################################################################
def type_query(query):
    q=query.replace(".","").replace("]"," ").replace("["," ").replace(","," ").replace("?","").replace("/"," / ").split()
    global st

    #stemming the query
    Q=[porter.stem(x.lower()) for x in q]
    swquery = [x for x in Q if x not in stwl]
       
    p_val=0
    #identifying the proximity query
    if '/' in Q:
        p_val = int(swquery[swquery.index('/')+1])
        w1=swquery[0]
        w2=swquery[1]
        if p_val != 0:
            ProximityQueryProcessing(w1,w2,p_val)
        else:
            st= "invalid proximity query"
    else :
        complex_query(query)
###################################################################################################################################################################################################################################################################################################################################################################################################################


###################################################################################################################################################################################################################################################################################################################################################################################################################
def complex_query(query):
    query = query.split()
    global st

    if len(query) == 1:
        if i_index.get(query[0],0) != 0:
            st=str(i_index[query[0]])
        else:
            st = "Doc not found" 
    else:          
        prec = {}  
        prec['not']=3
        prec['or']=2
        prec['and']=1
        pfquery=[]
        myStack=[]
        result=[]
        for q in query:
            if q not in prec:
                pfquery.append(q)
            else:
                while (len(myStack)!=0) and (prec[myStack[-1]]>=prec[q]):
                    pfquery.append(myStack.pop())
                myStack.append(q)                                           
        while len(myStack) !=0:
            pfquery.append(myStack.pop())                                   
        for x in pfquery:
            if x not in prec:
                if i_index.get(x,0) != 0:
                    result.append(set(i_index[x]))
                else:
                    result.append(set()) 
            if x == 'not' :
                y = result.pop()
                result.append(set(dic.keys())-y)     
            if x == 'and' :
                y = result.pop()
                z = result.pop()
                result.append(z.intersection(y))    
            if x == 'or' :
                y = result.pop()
                z = result.pop()
                result.append(z.union(y))   
        st = str(result)

###################################################################################################################################################################################################################################################################################################################################################################################################################


###################################################################################################################################################################################################################################################################################################################################################################################################################
def checkPositions(word1, word2, ProximityValue,commonDoc): 
    result = []
    for pos1 in word1:
        for pos2 in word2:
            if (abs(pos1-pos2)-1) == ProximityValue:
                print("DOC--> ",commonDoc,"-->pos1(",pos1,") - pos2(",pos2,")",abs(pos1-pos2)-1)
                result.append(commonDoc)
            else:
                  pass
                # print("false statement : \n","DOC--> ",commonDoc,"-->pos1(",pos1,") - pos2(",pos2,")",abs(pos1-pos2)-1)
    return result
###################################################################################################################################################################################################################################################################################################################################################################################################################


###################################################################################################################################################################################################################################################################################################################################################################################################################
def ProximityQueryProcessing(w1, w2, ProximityValue):
    global p_index
    global st
    word1={}
    word2={}
    for w in p_index.keys():
        if w == w1:
            for docid in p_index[w]:
                word1[docid]=p_index[w][docid]
        elif w == w2:
            for docid in p_index[w]:
                word2[docid]=p_index[w][docid]
                
    s1=set(word1.keys())
    s2=set(word2.keys())
    commonDoc=None
    commonDoc=s1.intersection(s2)
    
    print("s1 : ",s1,"\n\ns2 : ",s2)
    print("\n\n## Common in : ",commonDoc,"\n")
    result=[]
    if commonDoc is not None:
        for commonDoc in commonDoc:
                x=checkPositions(word1[commonDoc],word2[commonDoc], ProximityValue,commonDoc)
                if len(x)>0:
                    result.append(commonDoc)
    else:
        st = "result not found"
        text.insert('1.0',st)

        
    st = "no of doc in result : " + str(len(result))+ "\nDocs -->" + str(result)   
###################################################################################################################################################################################################################################################################################################################################################################################################################
def main(lsl):
    query = lsl
    read_i_index() 
    type_query(query)                                        
###################################################################################################################################################################################################################################################################################################################################################################################################################
window=Tk()

window.resizable(0,0)
fram = Frame(window)
Label(fram,text='Search:').pack(side=LEFT)
string = Entry(fram)
string.pack(side=LEFT, fill=BOTH, expand=1)
string.focus_set()
lsl = string.get()
butt = Button(fram, text='GO!')
butt.pack(side=RIGHT)
fram.pack(side=TOP)
butt.config(command=main(lsl))
text = Text(window)
text.pack(side=BOTTOM)
text.insert('1.0',st)    
window.title('Hello Python')
window.geometry("800x500+450+220")
window.mainloop()
###################################################################################################################################################################################################################################################################################################################################################################################################################
